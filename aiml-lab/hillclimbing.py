import matplotlib.pyplot as plt
import numpy as np

def f(x):
    return -x**2  # Example objective function

def hill_climbing(initial_x, max_iterations=1000, step_size=0.9, stagnation_limit=100):
    current_x = initial_x
    iteration = 0
    current_value = f(current_x)

    x_values = [current_x]
    y_values = [f(current_x)]

    no_improvement_count = 0  # Counter for no improvement

    while iteration < max_iterations:
        # Generate neighbors
        neighbor_x = current_x + step_size * np.random.uniform(-1, 1)
        neighbor_value = f(neighbor_x)

        # Select the best neighbor
        if neighbor_value > current_value:  # Maximize the objective function
            current_x = neighbor_x
            current_value = neighbor_value
            x_values.append(current_x)
            y_values.append(current_value)
            no_improvement_count = 0  # Reset no improvement counter
        else:
            no_improvement_count += 1

        # Check if no improvement for a certain number of iterations
        if no_improvement_count >= stagnation_limit:
            print(f"Termination: No improvement after {stagnation_limit} iterations.")
            break

        iteration += 1

    return current_x, f(current_x), x_values, y_values

initial_x = float(input("Enter the initial value for x: "))

best_solution, best_value, x_values, y_values = hill_climbing(initial_x)

print(f"x = {best_solution}")
print(f"f(x) = {best_value}")

# Generate original function curve
original_x_values = np.linspace(min(x_values), max(x_values), 1000)
original_y_values = [f(x) for x in original_x_values]

# Plot both original function curve and points generated by hill climbing
plt.plot(original_x_values, original_y_values)
plt.plot(x_values, y_values)
plt.title("Hill Climbing Algorithm")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()
